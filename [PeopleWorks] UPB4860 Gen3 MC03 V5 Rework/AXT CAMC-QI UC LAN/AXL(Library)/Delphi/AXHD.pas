unit AXHD;

interface
uses Windows, Messages; 
{     IP COMMAND LIST                             }
const
    { PGM-1 Group Register         }
    IPxyRANGERead             = $00;      // PGM-1 RANGE READ, 16bit, $FFFF
    IPxyRANGEWrite            = $80;      // PGM-1 RANGE WRITE
    IPxySTDRead               = $01;      // PGM-1 START/STOP SPEED DATA READ, 16bit
    IPxySTDWrite              = $81;      // PGM-1 START/STOP SPEED DATA WRITE
    IPxyOBJRead               = $02;      // PGM-1 OBJECT SPEED DATA READ, 16bit
    IPxyOBJWrite              = $82;      // PGM-1 OBJECT SPEED DATA WRITE
    IPxyRATE1Read             = $03;      // PGM-1 RATE-1 DATA READ, 16bit, $FFFF
    IPxyRATE1Write            = $83;      // PGM-1 RATE-1 DATA WRITE
    IPxyRATE2Read             = $04;      // PGM-1 RATE-2 DATA READ, 16bit, $FFFF
    IPxyRATE2Write            = $84;      // PGM-1 RATE-2 DATA WRITE
    IPxyRATE3Read             = $05;      // PGM-1 RATE-3 DATA READ, 16bit, $FFFF
    IPxyRATE3Write            = $85;      // PGM-1 RATE-3 DATA WRITE
    IPxyRCP12Read             = $06;      // PGM-1 RATE CHANGE POINT 1-2 READ, 16bit, $FFFF
    IPxyRCP12Write            = $86;      // PGM-1 RATE CHANGE POINT 1-2 WRITE
    IPxyRCP23Read             = $07;      // PGM-1 RATE CHANGE POINT 2-3 READ, 16bit, $FFFF
    IPxyRCP23Write            = $87;      // PGM-1 RATE CHANGE POINT 2-3 WRITE
    IPxySW1Read               = $08;      // PGM-1 SW-1 DATA READ, 15bit, $7FFF
    IPxySW1Write              = $88;      // PGM-1 SW-1 DATA WRITE
    IPxySW2Read               = $09;      // PGM-1 SW-2 DATA READ, 15bit, $7FFF
    IPxySW2Write              = $89;      // PGM-1 SW-2 DATA WRITE
    IPxyPWMRead               = $0A;      // PGM-1 PWM output set DATA READ(0~6), 3bit, $00
    IPxyPWMWrite              = $8A;      // PGM-1 PWM output set DATA WRITE
    IPxyREARRead              = $0B;      // PGM-1 SLOW DOWN/REAR PULSE READ, 32bit, $00000000
    IPxyREARWrite             = $8B;      // PGM-1 SLOW DOWN/REAR PULSE WRITE
    IPxySPDRead               = $0C;      // PGM-1 현재 SPEED DATA READ, 16bit, $0000
    IPxyNoOperation_8C        = $8C;      // No operation
    IPxySPDCMPRead            = $0D;      // PGM-1 현재 SPEED 비교 DATA READ, 16bit, $0000
    IPxySPDCMPWrite           = $8D;      // PGM-1 현재 SPEED 비교 DATA WRITE
    IPxyDRVPULSERead          = $0E;      // PGM-1 DRIVE PULSE COUNTER READ, 32bit, $00000000
    IPxyNoOperation_8E        = $8E;      // No operation
    IPxyPRESETPULSERead       = $0F;      // PGM-1 PRESET PULSE DATA READ, 32bit, $00000000
    IPxyNoOperation_8F        = $8F;      // No operation
    { PGM-1 Update Group Register  }      
    IPxyURANGERead            = $10;      // PGM-1 UP-DATE RANGE READ, 16bit, $FFFF
    IPxyURANGEWrite           = $90;      // PGM-1 UP-DATE RANGE WRITE
    IPxyUSTDRead              = $11;      // PGM-1 UP-DATE START/STOP SPEED DATA READ, 16bit
    IPxyUSTDWrite             = $91;      // PGM-1 UP-DATE START/STOP SPEED DATA WRITE
    IPxyUOBJRead              = $12;      // PGM-1 UP-DATE OBJECT SPEED DATA READ, 16bit
    IPxyUOBJWrite             = $92;      // PGM-1 UP-DATE OBJECT SPEED DATA WRITE
    IPxyURATE1Read            = $13;      // PGM-1 UP-DATE RATE-1 DATA READ, 16bit, $FFFF
    IPxyURATE1Write           = $93;      // PGM-1 UP-DATE RATE-1 DATA WRITE
    IPxyURATE2Read            = $14;      // PGM-1 UP-DATE RATE-2 DATA READ, 16bit, $FFFF
    IPxyURATE2Write           = $94;      // PGM-1 UP-DATE RATE-2 DATA WRITE
    IPxyURATE3Read            = $15;      // PGM-1 UP-DATE RATE-3 DATA READ, 16bit, $FFFF
    IPxyURATE3Write           = $95;      // PGM-1 UP-DATE RATE-3 DATA WRITE
    IPxyURCP12Read            = $16;      // PGM-1 UP-DATE RATE CHANGE POINT 1-2 READ, 16bit, $FFFF
    IPxyURCP12Write           = $96;      // PGM-1 UP-DATE RATE CHANGE POINT 1-2 WRITE
    IPxyURCP23Read            = $17;      // PGM-1 UP-DATE RATE CHANGE POINT 2-3 READ, 16bit, $FFFF
    IPxyURCP23Write           = $97;      // PGM-1 UP-DATE RATE CHANGE POINT 2-3 WRITE
    IPxyUSW1Read              = $18;      // PGM-1 UP-DATE SW-1 DATA READ, 15bit, $7FFF
    IPxyUSW1Write             = $98;      // PGM-1 UP-DATE SW-1 DATA WRITE
    IPxyUSW2Read              = $19;      // PGM-1 UP-DATE SW-2 DATA READ, 15bit, $7FFF
    IPxyUSW2Write             = $99;      // PGM-1 UP-DATE SW-2 DATA WRITE
    IPxyNoOperation_1A        = $1A;      // No operation
    IPxyNoOperation_9A        = $9A;      // No operation
    IPxyUREARRead             = $1B;      // PGM-1 UP-DATE SLOW DOWN/REAR PULSE READ, 32bit, $00000000
    IPxyUREARWrite            = $9B;      // PGM-1 UP-DATE SLOW DOWN/REAR PULSE WRITE
    IPxySPDRead_1C            = $1C;      // PGM-1 UP-DATA CURRENT SPEED READ(Same with $0C)
    IPxyNoOperation_9C        = $9C;      // No operation
    IPxySPDCMPRead_1D         = $1D;      // PGM-1 currently SPEED compare DATA READ(Same with $0D)
    IPxySPDCMPWrite_9D        = $9D;      // PGM-1 currently SPEED compare DATA WRITE(Same with $8D)
    IPxyACCPULSERead          = $1E;      // PGM-1 acceleration PULSE COUNTER READ, 32bit, $00000000
    IPxyNoOperation_9E        = $9E;      // No operation
    IPxyPRESETPULSERead_1F    = $1F;      // PGM-1 PRESET PULSE DATA READ(Same with $0F)
    IPxyNoOperation_9F        = $9F;      // No operation
    { PGM-2 Group Register         }
    IPxyNoOperation_20        = $20;      // No operation
    IPxyPPRESETDRV            = $A0;      // +PRESET PULSE DRIVE, 32
    IPxyNoOperation_21        = $21;      // No operation
    IPxyPCONTDRV              = $A1;      // +CONTINUOUS DRIVE
    IPxyNoOperation_22        = $22;      // No operation
    IPxyPSCH1DRV              = $A2;      // +SIGNAL SEARCH-1 DRIVE
    IPxyNoOperation_23        = $23;      // No operation
    IPxyPSCH2DRV              = $A3;      // +SIGNAL SEARCH-2 DRIVE
    IPxyNoOperation_24        = $24;      // No operation
    IPxyPORGDRV               = $A4;      // +ORIGIN(ORG) SEARCH DRIVE
    IPxyNoOperation_25        = $25;      // No operation
    IPxyMPRESETDRV            = $A5;      // -PRESET PULSE DRIVE, 32
    IPxyNoOperation_26        = $26;      // No operation
    IPxyMCONTDRV              = $A6;      // -CONTINUOUS DRIVE
    IPxyNoOperation_27        = $27;      // No operation
    IPxyMSCH1DRV              = $A7;      // -SIGNAL SEARCH-1 DRIVE
    IPxyNoOperation_28        = $28;      // No operation
    IPxyMSCH2DRV              = $A8;      // -SIGNAL SEARCH-2 DRIVE
    IPxyNoOperation_29        = $29;      // No operation
    IPxyMORGDRV               = $A9;      // -ORIGIN(ORG) SEARCH DRIVE
    IPxyPULSEOVERRead         = $2A;      // Preset/MPG drive override pulse data read
    IPxyPULSEOVERWrite        = $AA;      // PRESET PULSE DATA OVERRIDE(ON_BUSY)
    IPxyNoOperation_2B        = $2B;      // No operation
    IPxySSTOPCMD              = $AB;      // SLOW DOWN STOP
    IPxyNoOperation_2C        = $2C;      // No operation
    IPxyESTOPCMD              = $AC;      // EMERGENCY STOP
    IPxyDRIVEMODERead         = $2D;      // Drive setting DATA READ
    IPxyDRIVEMODEWrite        = $AD;      // Drive setting DATA WRITE
    IPxyMPGCONRead            = $2E;      // MPG OPERATION SETTING DATA READ, 3bit, $00
    IPxyMPGCONWrite           = $AE;      // MPG OPERATION SETTING DATA WRITE
    IPxyPULSEMPGRead          = $2F;      // MPG PRESET PULSE DATA READ, 32bit, $00000000
    IPxyPULSEMPGWrite         = $AF;      // MPG PRESET PULSE DATA WRITE
    { Extension Group Register }
    IPxyNoOperation_30        = $30;      // No operation
    IPxyPSPO1DRV              = $B0;      // +SENSOR POSITIONING DRIVE I
    IPxyNoOperation_31        = $31;      // No operation
    IPxyMSPO1DRV              = $B1;      // -SENSOR POSITIONING DRIVE I
    IPxyNoOperation_32        = $32;      // No operation
    IPxyPSPO2DRV              = $B2;      // +SENSOR POSITIONING DRIVE II
    IPxyNoOperation_33        = $33;      // No operation
    IPxyMSPO2DRV              = $B3;      // -SENSOR POSITIONING DRIVE II
    IPxyNoOperation_34        = $34;      // No operation
    IPxyPSPO3DRV              = $B4;      // +SENSOR POSITIONING DRIVE III
    IPxyNoOperation_35        = $35;      // No operation
    IPxyMSPO3DRV              = $B5;      // -SENSOR POSITIONING DRIVE III
    IPxySWLMTCONRead          = $36;      // SOFT LIMIT 설정 READ, 3bit, $00
    IPxySWLMTCONWrite         = $B6;      // SOFT LIMIT 설정 WRITE
    IPxyMSWLMTCOMPRead        = $37;      // -SOFT LIMIT 비교 레지스터 설정 READ, 32bit, $80000000
    IPxyMSWLMTCOMPWrite       = $B7;      // -SOFT LIMIT 비교 레지스터 설정 WRITE
    IPxyPSWLMTCOMPRead        = $38;      // +SOFT LIMIT 비교 레지스터 설정 READ, 32bit, $7FFFFFFF
    IPxyPSWLMTCOMPWrite       = $B8;      // +SOFT LIMIT 비교 레지스터 설정 WRITE
    IPxyTRGCONRead            = $39;      // TRIGGER MODE 설정 READ, 32bit, $00010000
    IPxyTRGCONWrite           = $B9;      // TRIGGER MODE 설정 WRITE
    IPxyTRGCOMPRead           = $3A;      // TRIGGER 비교 데이터 설정 READ, 32bit, $00000000
    IPxyTRGCOMPWrite          = $BA;      // TRIGGER 비교 데이터 설정 WRITE
    IPxyICMRead               = $3B;      // INTERNAL M-DATA 설정 READ, 32bit, $80000000
    IPxyICMWrite              = $BB;      // INTERNAL M-DATA 설정 WRITE
    IPxyECMRead               = $3C;      // EXTERNAL M-DATA 설정 READ, 32bit, $80000000
    IPxyECMWrite              = $BC;      // EXTERNAL M-DATA 설정 WRITE
    IPxySTOPPWRead            = $3D;      // Stop pulse width Read
    IPxySTOPPWWrite           = $BD;      // Stop pulse width Write
    IPxyNoOperation_3E        = $3E;      // No operation
    IPxyNoOperation_BE        = $BE;      // No operation
    IPxyNoOperation_3F        = $3F;      // No operation
    IPxyTRGCMD                = $BF;      // TRIG output signal generation command
    { Interpolation Group    Registers}
    IPxCIRXCRead              = $40;      // Circular interpolation X axis center point read
    IPxCIRXCWrite             = $C0;      // Circular interpolation X axis center point write
    IPxCIRYCRead              = $41;      // Circular interpolation Y axis center point read
    IPxCIRYCWrite             = $C1;      // Circular interpolation Y axis center point write
    IPxENDXRead               = $42;      // Interpolation X axis end point read
    IPxENDXWrite              = $C2;      // Interpolation X axis end point write
    IPxENDYRead               = $43;      // Interpolation Y axis end point read
    IPxENDYWrite              = $C3;      // Interpolation Y axis end point write
    IPxPTXENDRead             = $44;      // Pattern interpolation X Queue data read
    IPxPTXENDWrite            = $C4;      // Pattern interpolation X Queue data with queue push 
    IPxPTYENDRead             = $45;      // Pattern interpolation Y Queue data read 
    IPxPTYENDWrite            = $C5;      // Pattern interpolation Y Queue data write
    IPxPTQUEUERead            = $46;      // Pattern interpolation Queue index read
    IPxNoOperation_C6         = $C6;      // No operation
    IPxNoOperation_47         = $47;      // No operation
    IPxNoOperation_C7         = $C7;      // No operation
    IPxNoOperation_48         = $48;      // No operation
    IPxNoOperation_C8         = $C8;      // No operation
    IPxNoOperation_49         = $49;      // No operation
    IPxNoOperation_C9         = $C9;      // No operation
    IPxINPSTATUSRead          = $4A;      // Interpolation Status register read
    IPxNoOperation_CA         = $CA;      // No operation
    IPxINPMODE_4B             = $4B;      // Interpolation mode in Queue TOP contets
    IPxLINPDRV                = $CB;      // Linear interpolation with Queue push
    IPxINPMODE_4C             = $4C;      // Interpolation mode in Queue TOP contets
    IPxCINPDRV                = $CC;      // Circular interpolation with Queue push 
    IPxBPINPMODE              = $4D;      // Bit Pattern Interpolation mode in Queue TOP contets
    IPxBPINPDRV               = $CD;      // Bit pattern Drive
    IPxNoOperation_4E         = $4E;      // No Operation
    IPxNoOperation_CE         = $CE;      // No Operation
    IPxNoOperation_4F         = $4F;      // No Operation
    IPxNoOperation_CF         = $CF;      // No Operation
    { Arithemetic Group Register   }
    IPxNoOperation_50         = $50;      // No Operation
    IPxINPCLR                 = $D0;      // Initialize all interpolation control block
    IPxINPMPOINTRead          = $51;      // Interpolation deceleration manual point(unsigned) read
    IPxINPMPOINTWrite         = $D1;      // Interpolation deceleration manual point(unsigned) write
    IPxNoOperation_52         = $52;      // No Operation
    IPxINPCLRSWrite           = $D2;      // Initialize interpolation control block with target selection
    IPxNoOperation_53         = $53;      // No Operation
    IPxINPDRVWrite            = $D3;      // linear/circular drive start with queue data(Hold on mode), Restart on pause
    IPxNoOperation_54         = $54;      // No operation
    IPxNoOperation_D4         = $D4;      // No operation
    IPxNoOperation_55         = $55;      // No operation
    IPxARTSHOT                = $D5;      // Arithmetic block One time execution
    IPxARTSHOPERRead          = $56;      // Arithmetic block shift and operation selection Read
    IPxARTSHOPERWrite         = $D6;      // Arithmetic block shift and operation selection Write
    IPxARTSHRead              = $57;      // Arithmetic block shift amount data Read
    IPxARTSHWrite             = $D7;      // Arithmetic block shift amount data Write
    IPxARTSOURCERead          = $58;      // Arithmetic block operand configure data Read
    IPxARTSOURCEWrite         = $D8;      // Arithmetic block operand configure data Write
    IPxARTCRESULT1Read        = $59;      // Arithmetic first compare result data Read
    IPxNoOperation_D9         = $D9;      // No Operation
    IPxARTCRESULT2Read        = $5A;      // Arithmetic second compare result data Read
    IPxNoOperation_DA         = $DA;      // No Operation
    IPxARTARESULT1Read        = $5B;      // Arithmetic first algebraic result data Read
    IPxNoOperation_DB         = $DB;      // No Operation
    IPxARTARESULT2Read        = $5C;      // Arithmetic second algebraic result data Read
    IPxNoOperation_DC         = $DC;      // No operation
    IPxARTUSERARead           = $5D;      // Arithmetic block User operand A Read
    IPxARTUSERAWrite          = $DD;      // Arithmetic block User operand A Write
    IPxARTUSERBRead           = $5E;      // Arithmetic block User operand B Read
    IPxARTUSERBWrite          = $DE;      // Arithmetic block User operand B Write
    IPxARTUSERCRead           = $5F;      // Arithmetic block User operand C Read
    IPxARTUSERCWrite          = $DF;      // Arithmetic block User operand C Write
    { Scripter Group Register      }
    IPySCRCON1Read            = $40;      // 스크립트 동작 설정 레지스터-1 READ, 32bit, $00000000
    IPySCRCON1Write           = $C0;      // 스크립트 동작 설정 레지스터-1 WRITE
    IPySCRCON2Read            = $41;      // 스크립트 동작 설정 레지스터-2 READ, 32bit, $00000000
    IPySCRCON2Write           = $C1;      // 스크립트 동작 설정 레지스터-2 WRITE
    IPySCRCON3Read            = $42;      // 스크립트 동작 설정 레지스터-3 READ, 32bit, $00000000 
    IPySCRCON3Write           = $C2;      // 스크립트 동작 설정 레지스터-3 WRITE
    IPySCRCONQRead            = $43;      // 스크립트 동작 설정 레지스터-Queue READ, 32bit, $00000000
    IPySCRCONQWrite           = $C3;      // 스크립트 동작 설정 레지스터-Queue WRITE
    IPySCRDATA1Read           = $44;      // 스크립트 동작 데이터 레지스터-1 READ, 32bit, $00000000 
    IPySCRDATA1Write          = $C4;      // 스크립트 동작 데이터 레지스터-1 WRITE
    IPySCRDATA2Read           = $45;      // 스크립트 동작 데이터 레지스터-2 READ, 32bit, $00000000 
    IPySCRDATA2Write          = $C5;      // 스크립트 동작 데이터 레지스터-2 WRITE
    IPySCRDATA3Read           = $46;      // 스크립트 동작 데이터 레지스터-3 READ, 32bit, $00000000 
    IPySCRDATA3Write          = $C6;      // 스크립트 동작 데이터 레지스터-3 WRITE
    IPySCRDATAQRead           = $47;      // 스크립트 동작 데이터 레지스터-Queue READ, 32bit, $00000000 
    IPySCRDATAQWrite          = $C7;      // 스크립트 동작 데이터 레지스터-Queue WRITE
    IPyNoOperation_48         = $48;      // No operation
    IPySCRQCLR                = $C8;      // 스크립트 Queue clear
    IPySCRCQSIZERead          = $49;      // 스크립트 동작 설정 Queue 인덱스 READ, 4bit, $00
    IPyNoOperation_C9         = $C9;      // No operation
    IPySCRDQSIZERead          = $4A;      // 스크립트 동작 데이터 Queue 인덱스 READ, 4bit, $00
    IPyNoOperation_CA         = $CA;      // No operation
    IPySCRQFLAGRead           = $4B;      // 스크립트 Queue Full/Empty Flag READ, 4bit, $05
    IPyNoOperation_CB         = $CB;      // No operation
    IPySCRQSIZECONRead        = $4C;      // 스크립트 Queue size 설정(0~13) READ, 16bit, $D0D0
    IPySCRQSIZECONWrite       = $CC;      // 스크립트 Queue size 설정(0~13) WRITE
    IPySCRQSTATUSRead         = $4D;      // 스크립트 Queue status READ, 12bit, $005
    IPyNoOperation_CD         = $CD;      // No operation
    IPyNoOperation_4E         = $4E;      // No operation
    IPyNoOperation_CE         = $CE;      // No operation
    IPyNoOperation_4F         = $4F;      // No operation
    IPyNoOperation_CF         = $CF;      // No operation
    { Caption Group Register       }
    IPyCAPCON1Read            = $50;      // 갈무리 동작 설정 레지스터-1 READ, 32bit, $00000000
    IPyCAPCON1Write           = $D0;      // 갈무리 동작 설정 레지스터-1 WRITE
    IPyCAPCON2Read            = $51;      // 갈무리 동작 설정 레지스터-2 READ, 32bit, $00000000
    IPyCAPCON2Write           = $D1;      // 갈무리 동작 설정 레지스터-2 WRITE
    IPyCAPCON3Read            = $52;      // 갈무리 동작 설정 레지스터-3 READ, 32bit, $00000000 
    IPyCAPCON3Write           = $D2;      // 갈무리 동작 설정 레지스터-3 WRITE
    IPyCAPCONQRead            = $53;      // 갈무리 동작 설정 레지스터-Queue READ, 32bit, $00000000
    IPyCAPCONQWrite           = $D3;      // 갈무리 동작 설정 레지스터-Queue WRITE
    IPyCAPDATA1Read           = $54;      // 갈무리 동작 데이터 레지스터-1 READ, 32bit, $00000000 
    IPyNoOperation_D4         = $D4;      // No operation
    IPyCAPDATA2Read           = $55;      // 갈무리 동작 데이터 레지스터-2 READ, 32bit, $00000000 
    IPyNoOperation_D5         = $D5;      // No operation
    IPyCAPDATA3Read           = $56;      // 갈무리 동작 데이터 레지스터-3 READ, 32bit, $00000000 
    IPyNoOperation_D6         = $D6;      // No operation
    IPyCAPDATAQRead           = $57;      // 갈무리 동작 데이터 레지스터-Queue READ, 32bit, $00000000 
    IPyNoOperation_D7         = $D7;      // No operation
    IPyNoOperation_58         = $58;      // No operation
    IPyCAPQCLR                = $D8;      // 갈무리 Queue clear
    IPyCAPCQSIZERead          = $59;      // 갈무리 동작 설정 Queue 인덱스 READ, 4bit, $00
    IPyNoOperation_D9         = $D9;      // No operation
    IPyCAPDQSIZERead          = $5A;      // 갈무리 동작 데이터 Queue 인덱스 READ, 4bit, $00
    IPyNoOperation_DA         = $DA;      // No operation
    IPyCAPQFLAGRead           = $5B;      // 갈무리 Queue Full/Empty Flag READ, 4bit, $05
    IPyNoOperation_DB         = $DB;      // No operation
    IPyCAPQSIZECONRead        = $5C;      // 갈무리 Queue size 설정(0~13) READ, 16bit, $D0D0
    IPyCAPQSIZECONWrite       = $DC;      // 갈무리 Queue size 설정(0~13) WRITE
    IPyCAPQSTATUSRead         = $5D;      // 갈무리 Queue status READ, 12bit, $005
    IPyNoOperation_DD         = $DD;      // No operation
    IPyNoOperation_5E         = $5E;      // No operation
    IPyNoOperation_DE         = $DE;      // No operation
    IPyNoOperation_5F         = $5F;      // No operation
    IPyNoOperation_DF         = $DF;      // No operation
    { BUS - 1 Group Register           }
    IPxyINCNTRead             = $60;      // INTERNAL COUNTER DATA READ(Signed), 32bit, $00000000
    IPxyINCNTWrite            = $E0;      // INTERNAL COUNTER DATA WRITE(Signed)
    IPxyINCNTCMPRead          = $61;      // INTERNAL COUNTER COMPARATE DATA READ(Signed), 32bit, $00000000
    IPxyINCNTCMPWrite         = $E1;      // INTERNAL COUNTER COMPARATE DATA WRITE(Signed)
    IPxyINCNTSCALERead        = $62;      // INTERNAL COUNTER PRE-SCALE DATA READ, 8bit, $00
    IPxyINCNTSCALEWrite       = $E2;      // INTERNAL COUNTER PRE-SCALE DATA WRITE
    IPxyICPRead               = $63;      // INTERNAL COUNTER P-DATA READ, 32bit, $7FFFFFFF
    IPxyICPWrite              = $E3;      // INTERNAL COUNTER P-DATA WRITE
    IPxyEXCNTRead             = $64;      // EXTERNAL COUNTER DATA READ READ(Signed), 32bit, $00000000
    IPxyEXCNTWrite            = $E4;      // EXTERNAL COUNTER DATA READ WRITE(Signed)
    IPxyEXCNTCMPRead          = $65;      // EXTERNAL COUNTER COMPARATE DATA READ(Signed), 32bit, $00000000
    IPxyEXCNTCMPWrite         = $E5;      // EXTERNAL COUNTER COMPARATE DATA WRITE(Signed)
    IPxyEXCNTSCALERead        = $66;      // EXTERNAL COUNTER PRE-SCALE DATA READ, 8bit, $00
    IPxyEXCNTSCALEWrite       = $E6;      // EXTERNAL COUNTER PRE-SCALE DATA WRITE
    IPxyEXPRead               = $67;      // EXTERNAL COUNTER P-DATA READ, 32bit, $7FFFFFFF
    IPxyEXPWrite              = $E7;      // EXTERNAL COUNTER P-DATA WRITE
    IPxyEXSPDRead             = $68;      // EXTERNAL SPEED DATA READ, 32bit, $00000000
    IPxyNoOperation_E8        = $E8;      // No operation
    IPxyEXSPDCMPRead          = $69;      // EXTERNAL SPEED COMPARATE DATA READ, 32bit, $00000000
    IPxyEXSPDCMPWrite         = $E9;      // EXTERNAL SPEED COMPARATE DATA WRITE
    IPxyEXFILTERDRead         = $6A;      // 외부 센서 필터 대역폭 설정 DATA READ, 32bit, $00050005
    IPxyEXFILTERDWrite        = $EA;      // 외부 센서 필터 대역폭 설정 DATA WRITE
    IPxyOFFREGIONRead         = $6B;      // OFF-RANGE DATA READ, 8bit, $00
    IPxyOFFREGIONWrite        = $EB;      // OFF-RANGE DATA WRITE
    IPxyDEVIATIONRead         = $6C;      // DEVIATION DATA READ, 16bit, $0000
    IPxyNoOperation_EC        = $EC;      // No operation
    IPxyPGMCHRead             = $6D;      // PGM REGISTER CHANGE DATA READ
    IPxyPGMCHWrite            = $ED;      // PGM REGISTER CHANGE DATA WRITE
    IPxyCOMPCONRead           = $6E;      // COMPARE REGISTER INPUT CHANGE DATA READ
    IPxyCOMPCONWrite          = $EE;      // COMPARE REGISTER INPUT CHANGE DATA WRITE
    IPxyNoOperation_6F        = $6F;      // No operation
    IPxyNoOperation_EF        = $EF;      // No operation
    { BUS - 2 Group Register            }
    IPxyFUNCONRead            = $70;      // 칩 기능 설정 DATA READ,
    IPxyFUNCONWrite           = $F0;      // 칩 기능 설정 DATA WRITE
    IPxyMODE1Read             = $71;      // MODE1 DATA READ,
    IPxyMODE1Write            = $F1;      // MODE1 DATA WRITE
    IPxyMODE2Read             = $72;      // MODE2 DATA READ,
    IPxyMODE2Write            = $F2;      // MODE2 DATA WRITE
    IPxyUIODATARead           = $73;      // UNIVERSAL IN READ,
    IPxyUIODATAWrite          = $F3;      // UNIVERSAL OUT WRITE
    IPxyENDSTATUSRead         = $74;      // END STATUS DATA READ,
    IPxyCLIMCLR               = $F4;      // Complete limit stop clear command
    IPxyMECHRead              = $75;      // MECHANICAL SIGNAL DATA READ, 13bit
    IPxyNoOperation_F5        = $F5;      // No operation
    IPxyDRVSTATUSRead         = $76;      // DRIVE STATE DATA READ, 20bit
    IPxyNoOperation_F6        = $F6;      // No operation
    IPxyEXCNTCLRRead          = $77;      // EXTERNAL COUNTER 설정 DATA READ, 9bit, $00
    IPxyEXCNTCLRWrite         = $F7;      // EXTERNAL COUNTER 설정 DATA WRITE
    IPxyNoOperation_78        = $78;      // No operation
    IPxySWRESET               = $F8;      // REGISTER CLEAR(INITIALIZATION), Software reset
    IPxyINTFLAG1Read          = $79;      // Interrupt Flag1 READ, 32bit, $00000000
    IPxyINTFLAG1CLRWrite      = $F9;      // Interrupt Flag1 Clear data write command.
    IPxyINTMASK1Read          = $7A;      // Interrupt Mask1 READ, 32bit, $00000001
    IPxyINTMASK1Write         = $FA;      // Interrupt Mask1 WRITE
    IPxyUIOMODERead           = $7B;      // UIO MODE DATA READ, 12bit, $01F
    IPxyUIOMODEWrite          = $FB;      // UIO MODE DATA WRITE
    IPxyINTFLAG2Read          = $7C;      // Interrupt Flag2 READ, 32bit, $00000000
    IPxyINTFLAG2CLRWrite      = $FC;      // Interrupt Flag2 Clear data write command.
    IPxyINTMASK2Read          = $7D;      // Interrupt Mask2 READ, 32bit, $00000001
    IPxyINTMASK2Write         = $FD;      // Interrupt Mask2 WRITE
    IPxyINTUSERCONRead        = $7E;      // User interrupt selection control.
    IPxyINTUSERCONWrite       = $FE;      // User interrupt selection control. 
    IPxyNoOperation_7F        = $7F;      // No operation
    IPxyINTGENCMD             = $FF;      // Interrupt generation command.

{     CAMC-QI COMMAND LIST         }
    { Previous and etc Registers   }
    QiPRANGERead              = $00;      // Previous RANGE READ
    QiPRANGEWrite             = $80;      // Previous RANGE WRITE
    QiPSTDRead                = $01;      // Previous START/STOP SPEED DATA READ
    QiPSTDWrite               = $81;      // Previous START/STOP SPEED DATA WRITE
    QiPOBJRead                = $02;      // Previous OBJECT SPEED DATA READ
    QiPOBJWrite               = $82;      // Previous OBJECT SPEED DATA WRITE
    QiPRATE1Read              = $03;      // Previous RATE-1 DATA READ
    QiPRATE1Write             = $83;      // Previous RATE-1 DATA WRITE
    QiPRATE2Read              = $04;      // Previous RATE-2 DATA READ
    QiPRATE2Write             = $84;      // Previous RATE-2 DATA WRITE
    QiPSW1Read                = $05;      // Previous SW-1 DATA READ
    QiPSW1Write               = $85;      // Previous SW-1 DATA WRITE
    QiPSW2Read                = $06;      // Previous SW-2 DATA READ
    QiPSW2Write               = $86;      // Previous SW-2 DATA WRITE
    QiPDCFGRead               = $07;      // Previous Drive configure data READ
    QiPDCFGWrite              = $87;      // Previous Drive configure data WRITE
    QiPREARRead               = $08;      // Previous SLOW DOWN/REAR PULSE READ
    QiPREARWrite              = $88;      // Previous SLOW DOWN/REAR PULSE WRITE
    QiPPOSRead                = $09;      // Previous Drive pulse amount data/Interpolation end position READ
    QiPPOSWrite               = $89;      // Previous Drive pulse amount data/Interpolation end position WRITE
    QiPCENTRead               = $0A;      // Previous Circular Int. center/Master axis target position for multiple chip linear int. READ 
    QiPCENTWrite              = $8A;      // Previous Circular Int. center/Master axis target position for multiple chip linear int. WRITE
    QiPISNUMRead              = $0B;      // Previous Interpolation step number READ
    QiPISNUMWrite             = $8B;      // Previous Interpolation step number WRITE
    QiNoOperation_0C          = $0C;      // No operation
    QiCLRPRE                  = $8C;      // Clear previous driving data Queue.
    QiNoOperation_0D          = $0D;      // No operation
    QiPOPPRE                  = $8D;      // Pop and shift data of previous driving data Queue.
    QiPPORTMARestore          = $0E;      // Restore data ports.
    QiPPORTMABackup           = $8E;      // Backup data ports.
    QiCURSPDRead              = $0F;      // Current SPEED DATA READ
    QiNoOperation_8F          = $8F;      // No operation
    { Working Registers            }
    QiRANGERead               = $10;      // RANGE READ
    QiRANGEWrite              = $90;      // RANGE WRITE
    QiSTDRead                 = $11;      // START/STOP SPEED DATA READ
    QiSTDWrite                = $91;      // START/STOP SPEED DATA WRITE
    QiOBJRead                 = $12;      // OBJECT SPEED DATA READ
    QiOBJWrite                = $92;      // OBJECT SPEED DATA WRITE
    QiRATE1Read               = $13;      // RATE-1 DATA READ
    QiRATE1Write              = $93;      // RATE-1 DATA WRITE
    QiRATE2Read               = $14;      // RATE-2 DATA READ
    QiRATE2Write              = $94;      // RATE-2 DATA WRITE
    QiSW1Read                 = $15;      // SW-1 DATA READ
    QiSW1Write                = $95;      // SW-1 DATA WRITE
    QiSW2Read                 = $16;      // SW-2 DATA READ
    QiSW2Write                = $96;      // SW-2 DATA WRITE
    QiDCFGRead                = $17;      // Drive configure data READ
    QiDCFGWrite               = $97;      // Drive configure data WRITE
    QiREARRead                = $18;      // SLOW DOWN/REAR PULSE READ
    QiREARWrite               = $98;      // SLOW DOWN/REAR PULSE WRITE
    QiPOSRead                 = $19;      // Drive pulse amount data/Interpolation end position READ
    QiPOSWrite                = $99;      // Drive pulse amount data/Interpolation end position WRITE
    QiCENTRead                = $1A;      // Circular Int. center/Master axis target position for multiple chip linear int. READ
    QiCENTWrite               = $9A;      // Circular Int. center/Master axis target position for multiple chip linear int. WRITE
    QiISNUMRead               = $1B;      // Interpolation step number READ
    QiISNUMWrite              = $9B;      // Interpolation step number WRITE
    QiREMAIN                  = $1C;      // Remain pulse data after stopping preset drive function abnormally.
    QiNoOperation_9C          = $9C;      // No operation
    QiOBJORGRead              = $1F;      // Original search object speed READ
    QiOBJORGWrite             = $9F;      // Original search object speed WRITE
    { Universal In/Out Setting     }
    QiUIOMRead                = $1D;      // Universal in/out terminal mode READ
    QiUIOMWrite               = $9D;      // Universal in/out terminal mode WRITE
    QiUIORead                 = $1E;      // Universal in/out terminal mode READ
    QiUIOWrite                = $9E;      // Universal in/out terminal mode WRIT
    { Drive Start Command          }
    QiNoOperation_20          = $20;      // No operation.
    QiSTRN                    = $A0;      // Normal profile mode drive start.(STD => OBJ => STD)
    QiNoOperation_21          = $21;      // No operation.
    QiSTRO                    = $A0;      // Start at OBJ profile mode drive start.(OBJ => STD)
    QiNoOperation_22          = $22;      // No operation.
    QiSTRCO                   = $A0;      // Constant speed profile #1 drive start.(OBJ)
    QiNoOperation_23          = $23;      // No operation.
    QiSTRCS                   = $A0;      // Constant speed profile #2 drive start.(STD)
    QiNoOperation_60          = $5C;      // No operation.
    QiASTRN                   = $DC;      // Normal profile mode drive start with DCFG7~0 bit data in DATAPL0 port.(STD => OBJ => STD)
    QiNoOperation_61          = $5D;      // No operation.
    QiASTRO                   = $DD;      // Start at OBJ profile mode drive start with DCFG7~0 bit data in DATAPL0 port.(OBJ => STD)
    QiNoOperation_62          = $5E;      // No operation.
    QiASTRCO                  = $DE;      // Constant speed profile #1 drive start with DCFG7~0 bit data in DATAPL0 port.(OBJ)
    QiNoOperation_63          = $5F;      // No operation.
    QiASTRCS                  = $DF;      // Constant speed profile #2 drive start with DCFG7~0 bit data in DATAPL0 port.(STD)
    { Drive Control Command        }
    QiNoOperation_24          = $24;      // No operation.
    QiSSTOP                   = $A4;      // Slow Down stop.
    QiNoOperation_25          = $25;      // No operation.
    QiSTOP                    = $A5;      // Immediately stop.
    QiNoOperation_26          = $26;      // No operation.
    QiSQRO1                   = $A6;      // Output one shot of the start pulse form SQSTR1 terminal.
    QiNoOperation_27          = $27;      // No operation.
    QiSQRO2                   = $A7;      // Output one shot of the start pulse form SQSTR2 terminal.
    QiNoOperation_28          = $28;      // No operation.
    QiSQRI1                   = $A8;      // Execution sync start function same as SQSTR1 input.
    QiNoOperation_29          = $29;      // No operation.
    QiSQRI2                   = $A9;      // Execution sync start function same as SQSTR2 input.
    QiNoOperation_2A          = $2A;      // No operation
    QiSQSTP1                  = $AA;      // Output one shot of the stop pulse from SQSTP1 terminal.
    QiNoOperation_2B          = $2B;      // No operation.
    QiSQSTP2                  = $AB;      // Output one shot of the stop pulse from SQSTP2 terminal.
    QiISCNTRead               = $2C;      // Interpolation stop counter value READ.
    QiNoOperation_AC          = $AC;      // No operation.
    QiISACNTRead              = $2D;      // Interpolation step counter READ for advanced deceleration mode .
    QiNoOperation_AD          = $AD;      // No operation.
    QiNoOperation_2E          = $2E;      // No operation.
    QiESTOP                   = $AE;      // Emergency stop all axis.
    QiNoOperation_2F          = $2F;      // No operation
    QiSWRESET                 = $AF;      // Software reset(all axis).
    // QiNoOperation_30       = $30;      // Driven pulse amount during last driving(Interpolation step counter for path move).
    // QiDRPCNTRead           = $B0;      // No operation
    QiDRPCNTRead              = $30;      // No operation
    QiNoOperation_B0          = $B0;      // Driven pulse amount during last driving(Interpolation step counter for path move).
    QiNoOperation_31          = $31;      // No operation
    QiINTGEN                  = $B1;      // Interrupt generation command.
    { Peripheral Function Setting  }
    QiNoOperation_33          = $32;      // No operation.
    QiTRGQPOP                 = $B2;      // Pop and shift data in trigger position queue.
    QiTRTMCFRead              = $33;      // Trigger/Timer configure READ.
    QiTRTMCFWrite             = $B3;      // Trigger/Timer configure WRITE.
    QiSNSMTRead               = $34;      // Software negative limit position READ.
    QiSNSMTWrite              = $B4;      // Software negative limit position WRITE.
    QiSPSMTRead               = $35;      // Software positive limit position READ.
    QiSPSMTWrite              = $B5;      // Software positive limit position WRITE.
    QiTRGPWRead               = $36;      // Trigger pulse width READ.
    QiTRGPWWrite              = $B6;      // Trigger pulse width WRITE.
    QiTRGSPRead               = $37;      // Trigger function start position READ.
    QiTRGSPWrite              = $B7;      // Trigger function start position WRITE.
    QiTRGEPRead               = $38;      // Trigger function end position READ.
    QiTRGEPWrite              = $B8;      // Trigger function end position WRITE.
    QiPTRGPOSRead             = $39;      // Trigger position or period queue data READ.
    QiPTRGPOSWrite            = $B9;      // Push trigger position or period queue.
    QiNoOperation_3A          = $3A;      // No operation.
    QiCLRTRIG                 = $BA;      // Clear trigger position or period queue.
    QiNoOperation_3B          = $3B;      // No operation.    
    QiTRGGEN                  = $BB;      // Generate one shot trigger pulse.
    QiTMRP1Read               = $3C;      // Timer #1 period data READ.
    QiTMRP1Write              = $BC;      // Timer #1 period data WRITE.
    QiTMRP2Read               = $3D;      // Timer #2 period data READ.
    QiTMRP2Write              = $BD;      // Timer #2 period data WRITE.
    QiTMR1GENstop             = $3E;      // Timer #1 stop.
    QiTMR1GENstart            = $BE;      // Timer #1 start.
    QiTMR2GENstop             = $3F;      // Timer #2 stop.
    QiTMR2GENstart            = $BF;      // Timer #2 start.
    QiERCReset                = $60;      // ERC signal reset.
    QiERCSet                  = $E0;      // ERC signal set.
    { Script1/2/3 Setting Registers}
    QiSCRCON1Read             = $40;      // Script1 control queue register READ.
    QiSCRCON1Write            = $C0;      // Script1 control queue register WRITE.
    QiSCRCMD1Read             = $41;      // Script1 command queue register READ.
    QiSCRCMD1Write            = $C1;      // Script1 command queue register WRITE.
    QiSCRDAT1Read             = $42;      // Script1 execution data queue register READ.
    QiSCRDAT1Write            = $C2;      // Script1 execution data queue register WRITE.
    QiCQ1Read                 = $43;      // Script1 captured data queue register(top of depth 15 Queue)READ.
    QiNoOperation_C3          = $C3;      // No operation.
    QiSCRCFG1Read             = $44;      // Script1 flag control register READ.
    QiSCRCFG1Write            = $C4;      // Script1 flag control register WRITE.
    QiSCRCON2Read             = $45;      // Script2 control queue register READ.
    QiSCRCON2Write            = $C5;      // Script2 control queue register WRITE.
    QiSCRCMD2Read             = $46;      // Script2 command queue register READ.
    QiSCRCMD2Write            = $C6;      // Script2 command queue register WRITE.
    QiSCRDAT2Read             = $47;      // Script2 execution data queue register READ.
    QiSCRDAT2Write            = $C7;      // Script2 execution data queue register WRITE.
    QiCQ2Read                 = $48;      // Script2 captured data queue register(top of depth 15 Queue)READ.
    QiNoOperation_C8          = $C8;      // No operation.
    QiSCRCFG2Read             = $49;      // Script2 flag control register READ.
    QiSCRCFG2Write            = $C9;      // Script2 flag control register WRITE.
    QiSCRCON3Read             = $4A;      // Script3 control register READ.
    QiSCRCON3Write            = $CA;      // Script3 control register WRITE.
    QiSCRCMD3Read             = $4B;      // Script3 command register READ.
    QiSCRCMD3Write            = $CB;      // Script3 command register WRITE.
    QiSCRDAT3Read             = $4C;      // Script3 execution data register READ.
    QiSCRDAT3Write            = $CC;      // Script3 execution data register WRITE.
    QiCQ3Read                 = $4D;      // Script3 captured data register READ.
    QiNoOperation_CD          = $CD;      // No operation.
    QiNoOperation_4E          = $4E;      // No operation.
    QiNoOperation_CE          = $CE;      // No operation.
    QiNoOperation_4F          = $4F;      // No operation.
    QiNoOperation_CF          = $CF;      // [No operation code for script reservation command].
    { Script4 & Script Registers   }
    QiSCRCON4Read             = $50;      // Script4 control register READ.
    QiSCRCON4Write            = $D0;      // Script4 control register WRITE.
    QiSCRCMD4Read             = $51;      // Script4 command register READ.
    QiSCRCMD4Write            = $D1;      // Script4 command register WRITE.
    QiSCRDAT4Read             = $52;      // Script4 execution data register READ.
    QiSCRDAT4Write            = $D2;      // Script4 execution data register WRITE.
    QiCQ4Read                 = $53;      // Script4 captured data register READ.
    QiNoOperation_D3          = $D3;      // No operation.
    QiSCRTGRead               = $54;      // Target source data setting READ.
    QiSCRTGWrite              = $D4;      // Target source data setting WRITE.
    QiSCRSTAT1Read            = $55;      // Script status #1 READ.
    QiNoOperation_D5          = $D5;      // No operation.
    QiSCRSTAT2Read            = $56;      // Script status #2 READ.
    QiNoOperation_D6          = $D6;      // No operation.
    QiNoOperation_57          = $57;      // No operation.
    QiINITSQWrite             = $D7;      // Initialize script queues with target selection.
    QiNoOperation_58          = $58;      // No operation.
    QiINITCQWrite             = $D8;      // Initialize captured data queue with target selection.
    QiSCRMRead                = $59;      // Set enable mode with target selection READ.
    QiSCRMWrite               = $D9;      // Set enable mode with target selection WRITE.
    QiNoOperation_5A          = $5A;      // No operation.
    QiSQ1POP                  = $DA;      // Pop and shift data of script1 queue.
    QiNoOperation_5B          = $5B;      // No operation.
    QiSQ2POP                  = $DB;      // Pop and shift data of script2 queue.
    { Counter Function Registers   }
    QiCNTLBRead               = $61;      // Counter lower bound data READ.
    QiCNTLBWrite              = $E1;      // Counter lower bound data WRITE.
    QiCNTUBRead               = $62;      // Counter upper bound data READ.
    QiCNTUBWrite              = $E2;      // Counter upper bound data WRITE.
    QiCNTCF1Read              = $63;      // Counter configure #1 READ.
    QiCNTCF1Write             = $E3;      // Counter configure #1 WRITE.
    QiCNTCF2Read              = $64;      // Counter configure #2 READ.
    QiCNTCF2Write             = $E4;      // Counter configure #2 WRITE.
    QiCNTCF3Read              = $65;      // Counter configure #3 READ.
    QiCNTCF3Write             = $E5;      // Counter configure #3 WRITE.
    QiCNT1Read                = $66;      // Counter #1 data READ.
    QiCNT1Write               = $E6;      // Counter #1 data WRITE.
    QiCNT2Read                = $67;      // Counter #2 data READ.
    QiCNT2Write               = $E7;      // Counter #2 data WRITE.
    QiCNT3Read                = $68;      // Counter #3 data READ.
    QiCNT3Write               = $E8;      // Counter #3 data WRITE.
    QiCNT4Read                = $69;      // Counter #4 data READ.
    QiCNT4Write               = $E9;      // Counter #4 data WRITE.
    QiCNT5Read                = $6A;      // Counter #5 data READ.
    QiCNT5Write               = $EA;      // Counter #5 data WRITE.
    QiCNTC1Read               = $6B;      // Counter #1 comparator's data READ.
    QiCNTC1Write              = $EB;      // Counter #1 comparator's data WRITE.
    QiCNTC2Read               = $6C;      // Counter #2 comparator's data READ.
    QiCNTC2Write              = $EC;      // Counter #2 comparator's data WRITE.
    QiCNTC3Read               = $6D;      // Counter #3 comparator's data READ.
    QiCNTC3Write              = $ED;      // Counter #3 comparator's data WRITE.
    QiCNTC4Read               = $6E;      // Counter #4 comparator's data READ.
    QiCNTC4Write              = $EE;      // Counter #4 comparator's data WRITE.
    QiCNTC5Read               = $6F;      // Counter #5 comparator's data READ.
    QiCNTC5Write              = $EF;      // Counter #5 comparator's data WRITE.
    { Configure & Status Registers }
    QiUCFG1Read               = $70;      // Configure register #1 READ.
    QiUCFG1Write              = $F0;      // Configure register #1 WRITE.
    QiUCFG2Read               = $71;      // Configure register #2 READ.
    QiUCFG2Write              = $F1;      // Configure register #2 WRITE.
    QiUCFG3Read               = $72;      // Configure register #3 READ.
    QiUCFG3Write              = $F2;      // Configure register #3 WRITE.
    QiUCFG4Read               = $73;      // Configure register #4 READ.
    QiUCFG4Write              = $F3;      // Configure register #4 WRITE.
    QiNoOperation_74          = $74;      // No operation.
    QiNoOperation_F4          = $F4;      // No operation.
    QiNoOperation_75          = $75;      // No operation.
    QiNoOperation_F5          = $F5;      // No operation.
    QiNoOperation_76          = $76;      // No operation.
    QiNoOperation_F6          = $F6;      // No operation.
    QiIMASK1Read              = $77;      // Interrupt bank#1 mask register READ.
    QiIMASK1Write             = $F7;      // Interrupt bank#1 mask register WRITE.
    QiIMASK2Read              = $78;      // Interrupt bank#2 mask register READ.
    QiIMASK2Write             = $F8;      // Interrupt bank#2 mask register WRITE.
    QiSTAT1Read               = $79;      // Status register #1(END STATUS)READ.
    QiESCLR                   = $F9;      // Status register #1(END STATUS) Clear.
    QiSTAT2Read               = $7A;      // Status register #2 READ.
    QiNoOperation_FA          = $FA;      // No operation.
    QiSTAT3Read               = $7B;      // Status register #3 READ.
    QiNoOperation_FB          = $FB;      // No operation.
    QiSTAT4Read               = $7C;      // Status register #4 READ.
    QiNoOperation_FC          = $FC;      // No operation.
    QiSTAT5Read               = $7D;      // Status register #5 READ.
    QiNoOperation_FD          = $FD;      // No operation.
    QiIFLAG1Read              = $7E;      // Interrupt bank #1 flag READ.
    QiIFLAG1Clear             = $FE;      // Interrupt bank #1 flag Clear.
    QiIFLAG2Read              = $7F;      // Interrupt bank #2 flag READ.
    QiIFLAG2Clear             = $FF;      // Interrupt bank #2 flag Clear.
    
{     CAMC-QI Script/Caption Define}
    QI_SCR_REG1                           = 1;
    QI_SCR_REG2                           = 2;
    QI_SCR_REG3                           = 3;
    QI_SCR_REG4                           = 4;
    QI_OPERATION_ONCE_RUN                 = $00000000;      // bit 24 OFF
    QI_OPERATION_CONTINUE_RUN             = $01000000;      // bit 24 ON
    QI_INPUT_DATA_FROM_SCRIPT_DATA        = $00000000;      // bit 23 OFF
    QI_INPUT_DATA_FROM_TARGET_REG         = $00800000;      // bit 23 ON
    QI_INTERRUPT_GEN_ENABLE               = $00400000;      // bit 22 ON
    QI_INTERRUPT_GEN_DISABLE              = $00000000;      // bit 22 OFF
    QI_OPERATION_EVENT_NONE               = $00000000;      // bit 21=OFF, 20=OFF
    QI_OPERATION_EVENT_AND                = $00100000;      // bit 21=OFF, 20=ON
    QI_OPERATION_EVENT_OR                 = $00200000;      // bit 21=ON,  20=OFF
    QI_OPERATION_EVENT_XOR                = $00300000;      // bit 21=ON,  20=ON
                                          
{     CAMC-IP EVENT LIST           }      
    EVENT_IPNONE                          = $00;
    EVENT_IPDRIVE_END                     = $01;
    EVENT_IPPRESETDRIVE_START             = $02;
    EVENT_IPPRESETDRIVE_END               = $03;
    EVENT_IPCONTINOUSDRIVE_START          = $04;
    EVENT_IPCONTINOUSDRIVE_END            = $05;
    EVENT_IPSIGNAL_SEARCH_1_START         = $06;
    EVENT_IPSIGNAL_SEARCH_1_END           = $07;
    EVENT_IPSIGNAL_SEARCH_2_START         = $08;
    EVENT_IPSIGNAL_SEARCH_2_END           = $09;
    EVENT_IPORIGIN_DETECT_START           = $0A;
    EVENT_IPORIGIN_DETECT_END             = $0B;
    EVENT_IPSPEED_UP                      = $0C;
    EVENT_IPSPEED_CONST                   = $0D;
    EVENT_IPSPEED_DOWN                    = $0E;
    EVENT_IPICL                           = $0F;
    EVENT_IPICE                           = $10;
    EVENT_IPICG                           = $11;
    EVENT_IPECL                           = $12;
    EVENT_IPECE                           = $13;
    EVENT_IPECG                           = $14;
    EVENT_IPEPCE                          = $15;
    EVENT_IPEPCL                          = $16;
    EVENT_IPEPCG                          = $17;
    EVENT_IPSPL                           = $18;
    EVENT_IPSPE                           = $19;
    EVENT_IPSPG                           = $1A;
    EVENT_IPSP12L                         = $1B;
    EVENT_IPSP12E                         = $1C;
    EVENT_IPSP12G                         = $1D;
    EVENT_IPSP23L                         = $1E;
    EVENT_IPSP23E                         = $1F;
    EVENT_IPSP23G                         = $20;
    EVENT_IPOBJECT_SPEED                  = $21;
    EVENT_IPSS_SPEED                      = $22;
    EVENT_IPESTOP                         = $23;
    EVENT_IPSSTOP                         = $24;
    EVENT_IPPELM                          = $25;
    EVENT_IPNELM                          = $26;
    EVENT_IPPSLM                          = $27;
    EVENT_IPNSLM                          = $28;
    EVENT_IPDEVIATION_ERROR               = $29;
    EVENT_IPDATA_ERROR                    = $2A;
    EVENT_IPALARM_ERROR                   = $2B;
    EVENT_IPESTOP_COMMAND                 = $2C;
    EVENT_IPSSTOP_COMMAND                 = $2D;
    EVENT_IPESTOP_SIGNAL                  = $2E;
    EVENT_IPSSTOP_SIGNAL                  = $2F;
    EVENT_IPELM                           = $30;
    EVENT_IPSLM                           = $31;
    EVENT_IPINPOSITION                    = $32;
    EVENT_IPINOUT0_HIGH                   = $33;
    EVENT_IPINOUT0_LOW                    = $34;
    EVENT_IPINOUT1_HIGH                   = $35;
    EVENT_IPINOUT1_LOW                    = $36;
    EVENT_IPINOUT2_HIGH                   = $37;
    EVENT_IPINOUT2_LOW                    = $38;
    EVENT_IPINOUT3_HIGH                   = $39;
    EVENT_IPINOUT3_LOW                    = $3A;
    EVENT_IPINOUT4_HIGH                   = $3B;
    EVENT_IPINOUT4_LOW                    = $3C;
    EVENT_IPINOUT5_HIGH                   = $3D;
    EVENT_IPINOUT5_LOW                    = $3E;
    EVENT_IPINOUT6_HIGH                   = $3F;
    EVENT_IPINOUT6_LOW                    = $40;
    EVENT_IPINOUT7_HIGH                   = $41;
    EVENT_IPINOUT7_LOW                    = $42;
    EVENT_IPINOUT8_HIGH                   = $43;
    EVENT_IPINOUT8_LOW                    = $44;
    EVENT_IPINOUT9_HIGH                   = $45;
    EVENT_IPINOUT9_LOW                    = $46;
    EVENT_IPINOUT10_HIGH                  = $47;
    EVENT_IPINOUT10_LOW                   = $48;
    EVENT_IPINOUT11_HIGH                  = $49;
    EVENT_IPINOUT11_LOW                   = $4A;
    EVENT_IPSENSOR_DRIVE1_START           = $4B;
    EVENT_IPSENSOR_DRIVE1_END             = $4C;
    EVENT_IPSENSOR_DRIVE2_START           = $4D;
    EVENT_IPSENSOR_DRIVE2_END             = $4E;
    EVENT_IPSENSOR_DRIVE3_START           = $4F;
    EVENT_IPSENSOR_DRIVE3_END             = $50;
    EVENT_IP1STCOUNTER_NDATA_CLEAR        = $51;
    EVENT_IP2NDCOUNTER_NDATA_CLEAR        = $52;
    EVENT_IPMARK_SIGNAL_HIGH              = $53;
    EVENT_IPMARK_SIGNAL_LOW               = $54;
    EVENT_IPSOFTWARE_PLIMIT               = $55;
    EVENT_IPSOFTWARE_NLIMIT               = $56;
    EVENT_IPSOFTWARE_LIMIT                = $57;
    EVENT_IPTRIGGER_ENABLE                = $58;
    EVENT_IPINT_GEN_SOURCE                = $59;
    EVENT_IPINT_GEN_CMDF9                 = $5A;
    EVENT_IPPRESETDRIVE_TRI_START         = $5B;
    EVENT_IPBUSY_HIGH                     = $5C;
    EVENT_IPBUSY_LOW                      = $5D;
    EVENT_IPLINP_START                    = $5E;
    EVENT_IPLINP_END                      = $5F;
    EVENT_IPCINP_START                    = $60;
    EVENT_IPCINP_END                      = $61;
    EVENT_IPPINP_START                    = $62;
    EVENT_IPPINP_END                      = $63;
    EVENT_IPPDATA_Q_EMPTY                 = $64;
    EVENT_IPS_C_INTERNAL_COMMAND_Q_EMPTY  = $65;
    EVENT_IPS_C_INTERNAL_COMMAND_Q_FULL   = $66;
    EVENT_IPxSYNC_ACTIVATED               = $67;
    EVENT_IPySYNC_ACTIVATED               = $68;
    EVENT_IPINTERRUPT_GENERATED           = $69;
    EVENT_IPINP_START                     = $6A;
    EVENT_IPINP_END                       = $6B;
    EVENT_IPALGEBRIC_RESULT_BIT0          = $6C;
    EVENT_IPALGEBRIC_RESULT_BIT1          = $6D;
    EVENT_IPALGEBRIC_RESULT_BIT2          = $6E;
    EVENT_IPALGEBRIC_RESULT_BIT3          = $6F;
    EVENT_IPALGEBRIC_RESULT_BIT4          = $70;
    EVENT_IPALGEBRIC_RESULT_BIT5          = $71;
    EVENT_IPALGEBRIC_RESULT_BIT6          = $72;
    EVENT_IPALGEBRIC_RESULT_BIT7          = $73;
    EVENT_IPALGEBRIC_RESULT_BIT8          = $74;
    EVENT_IPALGEBRIC_RESULT_BIT9          = $75;
    EVENT_IPALGEBRIC_RESULT_BIT10         = $76;
    EVENT_IPALGEBRIC_RESULT_BIT11         = $77;
    EVENT_IPALGEBRIC_RESULT_BIT12         = $78;
    EVENT_IPALGEBRIC_RESULT_BIT13         = $79;
    EVENT_IPALGEBRIC_RESULT_BIT14         = $7A;
    EVENT_IPALGEBRIC_RESULT_BIT15         = $7B;
    EVENT_IPALGEBRIC_RESULT_BIT16         = $7C;
    EVENT_IPALGEBRIC_RESULT_BIT17         = $7D;
    EVENT_IPALGEBRIC_RESULT_BIT18         = $7E;
    EVENT_IPALGEBRIC_RESULT_BIT19         = $7F;
    EVENT_IPALGEBRIC_RESULT_BIT20         = $80;
    EVENT_IPALGEBRIC_RESULT_BIT21         = $81;
    EVENT_IPALGEBRIC_RESULT_BIT22         = $82;
    EVENT_IPALGEBRIC_RESULT_BIT23         = $83;
    EVENT_IPALGEBRIC_RESULT_BIT24         = $84;
    EVENT_IPALGEBRIC_RESULT_BIT25         = $85;
    EVENT_IPALGEBRIC_RESULT_BIT26         = $86;
    EVENT_IPALGEBRIC_RESULT_BIT27         = $87;
    EVENT_IPALGEBRIC_RESULT_BIT28         = $88;
    EVENT_IPALGEBRIC_RESULT_BIT29         = $89;
    EVENT_IPALGEBRIC_RESULT_BIT30         = $8A;
    EVENT_IPALGEBRIC_RESULT_BIT31         = $8B;
    EVENT_IPCOMPARE_RESULT_BIT0           = $8C;
    EVENT_IPCOMPARE_RESULT_BIT1           = $8D;
    EVENT_IPCOMPARE_RESULT_BIT2           = $8E;
    EVENT_IPCOMPARE_RESULT_BIT3           = $8F;
    EVENT_IPCOMPARE_RESULT_BIT4           = $90;
    EVENT_IPON_INTERPOLATION              = $91;
    EVENT_IPON_LINEAR_INTERPOLATION       = $92;
    EVENT_IPON_CIRCULAR_INTERPOLATION     = $93;
    EVENT_IPON_PATTERN_INTERPOLATION      = $94;
    EVENT_IPNONE_95                       = $95;
    EVENT_IPL_C_INP_Q_EMPTY               = $96;
    EVENT_IPL_C_INP_Q_LESS_4              = $97;
    EVENT_IPP_INP_Q_EMPTY                 = $98;
    EVENT_IPP_INP_Q_LESS_4                = $99;
    EVENT_IPINTERPOLATION_PAUSED          = $9A;
    EVENT_IPP_INP_END_BY_END_PATTERN      = $9B;
    EVENT_IPARITHMETIC_DATA_SEL           = $EE;
    EVENT_IPEXECUTION_ALWAYS              = $FF;

{     CAMC-QI EVENT LIST           }    
    EVENT_QINOOP                          = $00;            // No operation.
    EVENT_QIDRVEND                        = $01;            // Drive end event(inposition function excluded).
    EVENT_QIDECEL                         = $02;            // Deceleration state.
    EVENT_QICONST                         = $03;            // Constant speed state.
    EVENT_QIACCEL                         = $04;            // Acceleration state.
    EVENT_QICNT1L                         = $05;            // Counter1 < Comparater1 state.
    EVENT_QICNT1E                         = $06;            // Counter1 = Comparater1 state.
    EVENT_QICNT1G                         = $07;            // Counter1 > Comparater1 state.
    EVENT_QICNT1LE                        = $08;            // Counter1 ≤ Comparater1 state.
    EVENT_QICNT1GE                        = $09;            // Counter1 ≥ Comparater1 state.
    EVENT_QICNT1EUP                       = $0A;            // Counter1 = Comparater1 event during counting up.
    EVENT_QICNT1EDN                       = $0B;            // Counter1 = Comparater1 event during counting down.
    EVENT_QICNT1BND                       = $0C;            // Counter1 is same with boundary value.
    EVENT_QICNT2L                         = $0D;            // Counter2 < Comparater2 state.
    EVENT_QICNT2E                         = $0E;            // Counter2 = Comparater2 state.
    EVENT_QICNT2G                         = $0F;            // Counter2 > Comparater2 state.
    EVENT_QICNT2LE                        = $10;            // Counter2 ≤ Comparater2 state.
    EVENT_QICNT2GE                        = $11;            // Counter2 ≥ Comparater2 state.
    EVENT_QICNT2EUP                       = $12;            // Counter2 = Comparater2 event during counting up.
    EVENT_QICNT2EDN                       = $13;            // Counter2 = Comparater2 event during counting down.
    EVENT_QICNT2BND                       = $14;            // Counter2 is same with boundary value.
    EVENT_QICNT3L                         = $15;            // Counter3 < Comparater3 state.
    EVENT_QICNT3E                         = $16;            // Counter3 = Comparater3 state.
    EVENT_QICNT3G                         = $17;            // Counter3 > Comparater3 state.
    EVENT_QICNT3LE                        = $18;            // Counter3 ≤ Comparater3 state.
    EVENT_QICNT3GE                        = $19;            // Counter3 ≥ Comparater3 state.
    EVENT_QICNT3EUP                       = $1A;            // Counter3 = Comparater3 event during counting up.
    EVENT_QICNT3EDN                       = $1B;            // Counter3 = Comparater3 event during counting down.
    EVENT_QICNT3BND                       = $1C;            // Counter3 is same with boundary value.
    EVENT_QICNT4L                         = $1D;            // Counter4 < Comparater4 state.
    EVENT_QICNT4E                         = $1E;            // Counter4 = Comparater4 state.
    EVENT_QICNT4G                         = $1F;            // Counter4 > Comparater4 state.
    EVENT_QICNT4LE                        = $20;            // Counter4 ≤ Comparater4 state.
    EVENT_QICNT4GE                        = $21;            // Counter4 ≥ Comparater4 state.
    EVENT_QICNT4EUP                       = $22;            // Counter4 = Comparater4 event during counting up.
    EVENT_QICNT4EDN                       = $23;            // Counter4 = Comparater4 event during counting down.
    EVENT_QICNT4BND                       = $24;            // Counter4 is same with boundary value.
    EVENT_QICNT5L                         = $25;            // Counter5 < Comparater5 state.
    EVENT_QICNT5E                         = $26;            // Counter5 = Comparater5 state.
    EVENT_QICNT5G                         = $27;            // Counter5 > Comparater5 state.
    EVENT_QICNT5LE                        = $28;            // Counter5 ≤ Comparater5 state.
    EVENT_QICNT5GE                        = $29;            // Counter5 ≥ Comparater5 state.
    EVENT_QICNT5EUP                       = $2A;            // Counter5 = Comparater5 event during counting up.
    EVENT_QICNT5EDN                       = $2B;            // Counter5 = Comparater5 event during counting down.
    EVENT_QICNT5BND                       = $2C;            // Counter5 is same with boundary value.
    EVENT_QIDEVL                          = $2D;            // DEVIATION value < Comparater4 state.
    EVENT_QIDEVE                          = $2E;            // DEVIATION value = Comparater4 state.
    EVENT_QIDEVG                          = $2F;            // DEVIATION value > Comparater4 state.
    EVENT_QIDEVLE                         = $30;            // DEVIATION value ≤ Comparater4 state.
    EVENT_QIDEVGE                         = $31;            // DEVIATION value ≥ Comparater4 state.
    EVENT_QIPELM                          = $32;            // PELM input signal is activated state.
    EVENT_QINELM                          = $33;            // NELM input signal is activated state.
    EVENT_QIPSLM                          = $34;            // PSLM input signal is activated state.
    EVENT_QINSLM                          = $35;            // NSLM input signal is activated state.
    EVENT_QIALARM                         = $36;            // ALAMR input signal is activated state.
    EVENT_QIINPOS                         = $37;            // INPOSITION input signal ia activated state.
    EVENT_QIESTOP                         = $38;            // ESTOP input signal is activated state.
    EVENT_QIORG                           = $39;            // ORG input signal is activated state.
    EVENT_QIZ_PHASE                       = $3A;            // Z_PHASE input signal is activated state.
    EVENT_QIECUP                          = $3B;            // ECUP input signal is high level state.
    EVENT_QIECDN                          = $3C;            // ECDN input signal is high level state.
    EVENT_QIEXPP                          = $3D;            // EXPP input signal is high level state.
    EVENT_QIEXMP                          = $3E;            // EXMP input signal is high level state.
    EVENT_QISQSTR1                        = $3F;            // SYNC Start1 input signal is activated state(activated).
    EVENT_QISQSTR2                        = $40;            // SYNC Start2 input signal is activated state(activated).
    EVENT_QISQSTP1                        = $41;            // SYNC STOP1 input signal is activated state(activated).
    EVENT_QISQSTP2                        = $42;            // SYNC STOP2 input signal is activated state(activated).
    EVENT_QIALARMS                        = $43;            // At least one alarm signal of each axis is activated state.
    EVENT_QIUIO0                          = $44;            // UIO0 data is high state.
    EVENT_QIUIO1                          = $45;            // UIO1 data is high state.
    EVENT_QIUIO2                          = $46;            // UIO2 data is high state.
    EVENT_QIUIO3                          = $47;            // UIO3 data is high state.
    EVENT_QIUIO4                          = $48;            // UIO4 data is high state.
    EVENT_QIUIO5                          = $49;            // UIO5 data is high state.
    EVENT_QIUIO6                          = $4A;            // UIO6 data is high state.
    EVENT_QIUIO7                          = $4B;            // UIO7 data is high state.
    EVENT_QIUIO8                          = $4C;            // UIO8 data is high state.
    EVENT_QIUIO9                          = $4D;            // UIO9 data is high state.
    EVENT_QIUIO10                         = $4E;            // UIO10 data is high state.
    EVENT_QIUIO11                         = $4F;            // UIO11 data is high state.
    EVENT_QIERC                           = $50;            // ERC output is activated.
    EVENT_QITRG                           = $51;            // TRIGGER signal is activated.
    EVENT_QIPREQI0                        = $52;            // Previous queue data index 0 bit is high state.
    EVENT_QIPREQI1                        = $53;            // Previous queue data index 1 bit is high state.
    EVENT_QIPREQI2                        = $54;            // Previous queue data index 2 bit is high state.
    EVENT_QIPREQZ                         = $55;            // Previous queue is empty state.
    EVENT_QIPREQF                         = $56;            // Previous queue is full state.
    EVENT_QIMPGE1                         = $57;            // MPG first stage is overflowed state.
    EVENT_QIMPGE2                         = $58;            // MPG second stage is overflowed state.
    EVENT_QIMPGE3                         = $59;            // MPG third stage is overflowed state.
    EVENT_QIMPGERR                        = $5A;            // MPG all state is overflowed state.
    EVENT_QITRGCNT0                       = $5B;            // TRIGGER queue index bit 0 is high state.
    EVENT_QITRGCNT1                       = $5C;            // TRIGGER queue index bit 1 is high state.
    EVENT_QITRGCNT2                       = $5D;            // TRIGGER queue index bit 2 is high state.
    EVENT_QITRGCNT3                       = $5E;            // TRIGGER queue index bit 3 is high state.
    EVENT_QITRGQEPT                       = $5F;            // TRIGGER queue is empty state.
    EVENT_QITRGQFULL                      = $60;            // TRIGGER queue is full state.
    EVENT_QIDPAUSE                        = $61;            // Drive paused state.
    EVENT_QIESTOPEXE                      = $62;            // Emergency stop occurred
    EVENT_QISSTOPEXE                      = $63;            // Slowdown stop occurred
    EVENT_QIPLMTSTOP                      = $64;            // Limit stop event occurred during positive driving.
    EVENT_QINLMTSTOP                      = $65;            // Limit stop event occurred during negative driving.
    EVENT_QIOPLMTSTOP                     = $66;            // Optional limit stop event occurred during positive driving.
    EVENT_QIONLMTSTOP                     = $67;            // Optional limit stop event occurred during negative driving.
    EVENT_QIPSWESTOP                      = $68;            // Software emergency limit stop event occurred.(CW)
    EVENT_QINSWESTOP                      = $69;            // Software emergency limit stop event occurred.(CCW)
    EVENT_QIPSWSSTOP                      = $6A;            // Software slowdown limit stop event occurred.(CW)
    EVENT_QINSWSSTOP                      = $6B;            // Software slowdown limit stop event occurred.(CCW)
    EVENT_QIALMSTOP                       = $6C;            // Emergency stop event occurred by alarm signal function.
    EVENT_QIESTOPSTOP                     = $6D;            // Emergency stop event occurred by estop signal function.
    EVENT_QIESTOPCMD                      = $6E;            // Emergency stop event occurred by command.
    EVENT_QISSTOPCMD                      = $6F;            // Slowdown stop event occurred by command.
    EVENT_QIALLSTCMD                      = $70;            // Emergency stop event occurred by all stop command.
    EVENT_QISYSTOP1                       = $71;            // SYNC stop1 event occurred.
    EVENT_QISYSTOP2                       = $72;            // SYNC stop2 event occurred.
    EVENT_QIENCODERR                      = $73;            // Encoder input error event occurred.
    EVENT_QIMPGOVERFLOW                   = $74;            // MPG input error event occurred.
    EVENT_QIORGOK                         = $75;            // Original drive is executed successfully.
    EVENT_QISSCHOK                        = $76;            // Signal search drive is executed successfully.
    EVENT_QIUIO0LOW                       = $77;            // UIO0 data is low state.
    EVENT_QIUIO1LOW                       = $78;            // UIO1 data is low state.
    EVENT_QIUIO2LOW                       = $79;            // UIO2 data is low state.
    EVENT_QIUIO3LOW                       = $7A;            // UIO3 data is low state.
    EVENT_QIUIO4LOW                       = $7B;            // UIO4 data is low state.
    EVENT_QIUIO5LOW                       = $7C;            // UIO5 data is low state.
    EVENT_QIUIO6LOW                       = $7D;            // UIO6 data is low state.
    EVENT_QIUIO7LOW                       = $7E;            // UIO7 data is low state.
    EVENT_QIUIO8LOW                       = $7F;            // UIO8 data is low state.
    EVENT_QIUIO9LOW                       = $80;            // UIO9 data is low state.
    EVENT_QIUIO10LOW                      = $81;            // UIO10 data is low state.
    EVENT_QIUIO11LOW                      = $82;            // UIO11 data is low state.
    EVENT_QIUIO0RISING                    = $83;            // UIO0 rising edge event occurred.
    EVENT_QIUIO1RISING                    = $84;            // UIO1 rising edge event occurred.
    EVENT_QIUIO2RISING                    = $85;            // UIO2 rising edge event occurred.
    EVENT_QIUIO3RISING                    = $86;            // UIO3 rising edge event occurred.
    EVENT_QIUIO4RISING                    = $87;            // UIO4 rising edge event occurred.
    EVENT_QIUIO5RISING                    = $88;            // UIO5 rising edge event occurred.
    EVENT_QIUIO6RISING                    = $89;            // UIO6 rising edge event occurred.
    EVENT_QIUIO7RISING                    = $8A;            // UIO7 rising edge event occurred.
    EVENT_QIUIO8RISING                    = $8B;            // UIO8 rising edge event occurred.
    EVENT_QIUIO9RISING                    = $8C;            // UIO9 rising edge event occurred.
    EVENT_QIUIO10RISING                   = $8D;            // UIO10 rising edge event occurred.
    EVENT_QIUIO11RISING                   = $8E;            // UIO11 rising edge event occurred.
    EVENT_QIUIO0FALLING                   = $8F;            // UIO0 falling edge event occurred.
    EVENT_QIUIO1FALLING                   = $90;            // UIO1 falling edge event occurred.
    EVENT_QIUIO2FALLING                   = $91;            // UIO2 falling edge event occurred.
    EVENT_QIUIO3FALLING                   = $92;            // UIO3 falling edge event occurred.
    EVENT_QIUIO4FALLING                   = $93;            // UIO4 falling edge event occurred.
    EVENT_QIUIO5FALLING                   = $94;            // UIO5 falling edge event occurred.
    EVENT_QIUIO6FALLING                   = $95;            // UIO6 falling edge event occurred.
    EVENT_QIUIO7FALLING                   = $96;            // UIO7 falling edge event occurred.
    EVENT_QIUIO8FALLING                   = $97;            // UIO8 falling edge event occurred.
    EVENT_QIUIO9FALLING                   = $98;            // UIO9 falling edge event occurred.
    EVENT_QIUIO10FALLING                  = $99;            // UIO10 falling edge event occurred.
    EVENT_QIUIO11FALLING                  = $9A;            // UIO11 falling edge event occurred.
    EVENT_QIDRVSTR                        = $9B;            // Drive started.
    EVENT_QIDNSTR                         = $9C;            // Speed down event occurred.
    EVENT_QICOSTR                         = $9D;            // Constant speed event occurred.
    EVENT_QIUPSTR                         = $9E;            // Speed up event occurred.
    EVENT_QICONTISTR                      = $9F;            // Continuous drive started.
    EVENT_QIPRESETSTR                     = $A0;            // Preset drive started.
    EVENT_QIMPGSTR                        = $A1;            // MPG drive started.
    EVENT_QIORGSTR                        = $A2;            // Original drive started.
    EVENT_QISSCHSTR                       = $A3;            // Signal search drive started.
    EVENT_QIPATHSTR                       = $A4;            // Interpolation drive started.
    EVENT_QISLAVESTR                      = $A5;            // Slave drive started.
    EVENT_QICCWSTR                        = $A6;            // CCW direction drive started.
    EVENT_QIINPWAIT                       = $A7;            // Inposition wait event occurred.
    EVENT_QILINSTR                        = $A8;            // Linear drive stated.
    EVENT_QICIRSTR                        = $A9;            // Circular drive started.
    EVENT_QIDRVENDII                      = $AA;            // Drive stopped.(Inposition state included)
    EVENT_QIDNEND                         = $AB;            // Speed down end event occurred.
    EVENT_QICOEND                         = $AC;            // Constant speed end event occurred.
    EVENT_QIUPEND                         = $AD;            // Speed up end event occurred.
    EVENT_QICONTIEND                      = $AE;            // Continuous drive ended.
    EVENT_QIPRESETEND                     = $AF;            // Preset drive ended.
    EVENT_QIMPGEND                        = $B0;            // MPG drive ended.
    EVENT_QIORGEND                        = $B1;            // Original drive ended.
    EVENT_QISSCHEND                       = $B2;            // Signal search drive ended.
    EVENT_QIPATHEND                       = $B3;            // Interpolation drive ended.
    EVENT_QISLAVEEND                      = $B4;            // Slave drive ended.
    EVENT_QICCWEND                        = $B5;            // CCW direction drive ended.
    EVENT_QIINPEND                        = $B6;            // Escape from Inposition waiting.
    EVENT_QILINEND                        = $B7;            // Linear drive ended.
    EVENT_QICIREND                        = $B8;            // Circular drive ended.
    EVENT_QIBUSY                          = $B9;            // During driving state.
    EVENT_QINBUSY                         = $BA;            // During not driving state.
    EVENT_QITMR1EX                        = $BB;            // Timer1 expired event.
    EVENT_QITMR2EX                        = $BC;            // Timer2 expired event.
    EVENT_QIDRVENDIII                     = $BD;            // Drive(that interrupt enable bit is set to high) end event
    EVENT_QIERROR                         = $BE;            // Error stop occurred.
    //EVENT_QINOP                         = $BF;            // NOP.
    EVENT_QIALWAYS                        = $FF;            // Always Generate.

implementation

function QI_SND_EVENT_AXIS(Axis : LongInt) : LongInt;
begin
    result := (Axis mod 4) shl 18;
end;

function  QI_FST_EVENT_AXIS(Axis : LongInt) : LongInt;
begin
    result := (Axis mod 4) shl 16;
end;

function  QI_OPERATION_EVENT_2(Event : LongInt) : LongInt;
begin
    result := (Event and $FF) shl 8;
end;

function  QI_OPERATION_EVENT_1(Event : LongInt) : LongInt;
begin
    result := (Event and $FF);
end;

function  QI_OPERATION_COMMAND(Command : LongInt; Axis : LongInt) : LongInt;
begin
    result := ((Command and $FF) shl ((Axis mod 4) * 8));
end;

end.
